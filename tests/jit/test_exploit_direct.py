#!/usr/bin/env python3
"""Direct AST manipulation to test code injection vulnerability.

This test bypasses the GraphQL parser by directly constructing AST nodes
with malicious names to see if the JIT compiler is vulnerable.
"""

from graphql import parse

import strawberry
from strawberry.jit import JITCompiler

# Flag to detect if exploit succeeded
EXPLOIT_SUCCESS = {"pwned": False}


def mark_pwned():
    """This function should NEVER be called if the code is secure."""
    EXPLOIT_SUCCESS["pwned"] = True
    print("üö® EXPLOIT SUCCESSFUL! Code injection worked!")


@strawberry.type
class Query:
    @strawberry.field
    def hello(self, name: str = "World") -> str:
        return f"Hello, {name}!"


schema = strawberry.Schema(query=Query)


def test_direct_ast_manipulation():
    """Test by directly manipulating AST node names."""
    print("\n" + "=" * 70)
    print("DIRECT AST MANIPULATION TEST")
    print("=" * 70)
    print("\nAttempting to inject code through manually crafted AST nodes...")

    # Parse a normal query
    query = """
    query($userInput: String) {
        hello(name: $userInput)
    }
    """

    document = parse(query)

    # Now let's manually inspect and potentially modify the AST
    # to see what happens with malicious variable names
    print("\nüìã Inspecting parsed AST:")

    for definition in document.definitions:
        if hasattr(definition, "variable_definitions"):
            for var_def in definition.variable_definitions:
                var_name = var_def.variable.name.value
                print(f"  Variable: {var_name}")
                print(f"  Type: {type(var_def.variable.name)}")

    # Let's see what the JIT compiler generates
    compiler = JITCompiler(schema)

    try:
        compiled = compiler.compile_query(query)

        print("\nüìù Generated code inspection:")
        if hasattr(compiled, "_jit_source"):
            # Look for the variable access
            for i, line in enumerate(compiled._jit_source.split("\n"), 1):
                if "variable_values.get" in line:
                    print(f"  Line {i}: {line.strip()}")

            # Try to find any eval or exec calls (major red flag)
            if "eval(" in compiled._jit_source or "exec(" in compiled._jit_source:
                print("\nüö® WARNING: Found eval/exec in generated code!")

        print("\n‚úÖ Compilation succeeded")

        # Try to execute with malicious variable name (won't work through normal API)
        result = compiled(None, variables={"userInput": "'; mark_pwned(); '"})
        print(f"Result: {result}")

    except Exception as e:
        print(f"\n‚ùå Error: {type(e).__name__}: {e}")


def test_check_generated_code_structure():
    """Examine the structure of generated code for injection points."""
    print("\n" + "=" * 70)
    print("GENERATED CODE STRUCTURE ANALYSIS")
    print("=" * 70)

    queries_to_analyze = [
        ("Simple query", "query { hello }"),
        ("With variable", "query($var: String) { hello(name: $var) }"),
        ("With alias", "query { greeting: hello }"),
        ("Nested", "query { hello }"),  # We'll use a nested type later
    ]

    compiler = JITCompiler(schema)

    for name, query in queries_to_analyze:
        print(f"\nüìù {name}:")
        print(f"   Query: {query}")

        try:
            compiled = compiler.compile_query(query)

            if hasattr(compiled, "_jit_source"):
                # Count potential injection points
                injection_points = []

                lines = compiled._jit_source.split("\n")
                for i, line in enumerate(lines, 1):
                    # Look for f-strings or string formatting with user data
                    if ".get('" in line and "variable" in line:
                        injection_points.append(("Variable access", i, line.strip()))
                    if "type_map[" in line:
                        injection_points.append(("Type map access", i, line.strip()))
                    if "['" in line and ("result" in line or "kwargs" in line):
                        injection_points.append(("Dict key access", i, line.strip()))

                if injection_points:
                    print(
                        f"   Found {len(injection_points)} potential injection points:"
                    )
                    for point_type, line_num, line in injection_points[
                        :3
                    ]:  # Show first 3
                        print(f"     {point_type} at line {line_num}")
                        if len(line) > 80:
                            print(f"       {line[:77]}...")
                        else:
                            print(f"       {line}")
                else:
                    print("   No obvious injection points found")

        except Exception as e:
            print(f"   ‚ùå Error: {type(e).__name__}")


def test_string_escape_bypass():
    """Test if we can bypass string escaping."""
    print("\n" + "=" * 70)
    print("STRING ESCAPE BYPASS TEST")
    print("=" * 70)

    query = """
    query($input: String) {
        hello(name: $input)
    }
    """

    # Test various malicious inputs that might break out of strings
    malicious_inputs = [
        "'; mark_pwned(); '",
        '"; mark_pwned(); "',
        "\\'; mark_pwned(); \\'",
        "\n'; mark_pwned(); '",
        "\\x27; mark_pwned(); \\x27",
    ]

    compiler = JITCompiler(schema)
    compiled = compiler.compile_query(query)

    print("\nüî¨ Testing various escape bypass attempts...")

    for i, malicious in enumerate(malicious_inputs, 1):
        print(f"\n  Attempt {i}: {malicious!r}")
        try:
            result = compiled(None, variables={"input": malicious})
            print(f"    Result: {result['data']}")

            if EXPLOIT_SUCCESS["pwned"]:
                print("    üö® EXPLOIT WORKED!")
                break
        except Exception as e:
            print(f"    Error: {type(e).__name__}: {str(e)[:50]}")


def main():
    print("\n" + "=" * 70)
    print("JIT COMPILER DIRECT CODE INJECTION TESTS")
    print("=" * 70)
    print("\nThese tests bypass the GraphQL parser to directly test the JIT compiler's")
    print("resilience to code injection attacks.")

    test_direct_ast_manipulation()
    test_check_generated_code_structure()
    test_string_escape_bypass()

    print("\n" + "=" * 70)
    print("FINAL RESULT")
    print("=" * 70)

    if EXPLOIT_SUCCESS["pwned"]:
        print("üö® VULNERABILITY CONFIRMED!")
        print("   The mark_pwned() function was called - code injection succeeded!")
    else:
        print("‚úÖ No successful code injection")
        print("   Note: This doesn't mean the code is secure, just that these")
        print("   specific attack vectors were not successful.")

    print("\nüí° Recommendation:")
    print("   Even though these attacks failed, defense-in-depth dictates that")
    print("   we should add explicit sanitization of ALL user-controlled strings")
    print("   before embedding them in generated code.")

    print("\n" + "=" * 70)


if __name__ == "__main__":
    main()
