#!/usr/bin/env python3
"""Test for code injection vulnerability in JIT compiler.

This test attempts to exploit the JIT compiler by injecting malicious code
through GraphQL variable names, field aliases, and other user-controlled strings.
"""

import strawberry
from strawberry.jit import compile_query

# Flag to detect if exploit succeeded
EXPLOIT_FLAG = {"pwned": False}


@strawberry.type
class Query:
    @strawberry.field
    def hello(self, name: str = "World") -> str:
        return f"Hello, {name}!"


schema = strawberry.Schema(query=Query)


def test_variable_name_injection():
    """Attempt to inject code through variable name."""
    print("\n" + "=" * 70)
    print("TEST 1: Variable Name Injection")
    print("=" * 70)

    # Try to inject code through variable name
    # Normal GraphQL parsers should reject this, but let's try
    malicious_query = """
    query($myVar: String) {
        hello(name: $myVar)
    }
    """

    # Try with a malicious variable name in the compiled function
    # We can't directly control variable names in the query string,
    # but let's see what happens with the generated code

    try:
        compiled = compile_query(schema, malicious_query)

        # Check the generated source code
        if hasattr(compiled, "_jit_source"):
            print("\nüìù Generated Code Preview:")
            lines = compiled._jit_source.split("\n")
            for i, line in enumerate(lines[20:40], start=20):  # Show middle section
                print(f"  {i:3d}: {line}")

            # Look for variable access in the code
            if ".variable_values.get('" in compiled._jit_source:
                print("\n‚ö†Ô∏è  Found variable access in generated code")
                # Extract the line
                for line in compiled._jit_source.split("\n"):
                    if ".variable_values.get('" in line:
                        print(f"  {line.strip()}")

        result = compiled(None, variables={"myVar": "test"})
        print(f"\n‚úÖ Result: {result}")

    except Exception as e:
        print(f"\n‚ùå Error: {type(e).__name__}: {e}")


def test_field_alias_injection():
    """Attempt to inject code through field alias."""
    print("\n" + "=" * 70)
    print("TEST 2: Field Alias Injection")
    print("=" * 70)

    # GraphQL spec says aliases must be valid Names: [_A-Za-z][_0-9A-Za-z]*
    # But let's see if we can somehow bypass this

    # This should be rejected by the GraphQL parser
    queries_to_try = [
        # Try quotes
        'query { greeting: "]; EXPLOIT_FLAG[\\"pwned\\"] = True; x=[" hello }',
        # Try with backticks
        'query { greeting: `]; EXPLOIT_FLAG["pwned"] = True; x=[` hello }',
        # Try with special chars
        "query { greeting123: hello }",  # This should work
    ]

    for i, query in enumerate(queries_to_try, 1):
        print(f"\n  Attempt {i}: {query[:60]}...")
        try:
            compiled = compile_query(schema, query)
            result = compiled(None)
            print(f"    ‚úÖ Compiled and executed: {result}")
        except Exception as e:
            print(f"    ‚ùå {type(e).__name__}: {str(e)[:80]}")


def test_type_name_injection():
    """Attempt to inject through custom scalar type names."""
    print("\n" + "=" * 70)
    print("TEST 3: Type Name Injection")
    print("=" * 70)

    # Create a custom scalar with a malicious name (if possible)
    try:
        # Custom scalars are defined in code, not queries, so this is less of a concern
        # But let's check what happens if someone tries

        @strawberry.type
        class QueryWithScalar:
            @strawberry.field
            def test(self, arg: str) -> str:
                return arg

        schema2 = strawberry.Schema(query=QueryWithScalar)

        query = """
        query($val: String) {
            test(arg: $val)
        }
        """

        compiled = compile_query(schema2, query)

        # Check generated code for scalar parsers
        if hasattr(compiled, "_jit_source"):
            if "_scalar_parsers" in compiled._jit_source:
                print("\n‚ö†Ô∏è  Found scalar parser usage in generated code")
                for line in compiled._jit_source.split("\n"):
                    if "_scalar_parsers" in line:
                        print(f"  {line.strip()}")

        result = compiled(None, variables={"val": "test"})
        print(f"\n‚úÖ Result: {result}")

    except Exception as e:
        print(f"\n‚ùå Error: {type(e).__name__}: {e}")


def test_enum_value_injection():
    """Attempt to inject through enum values."""
    print("\n" + "=" * 70)
    print("TEST 4: Enum Value Injection")
    print("=" * 70)

    from enum import Enum

    @strawberry.enum
    class Priority(Enum):
        LOW = "low"
        HIGH = "high"

    @strawberry.type
    class Task:
        name: str
        priority: Priority

    @strawberry.type
    class QueryWithEnum:
        @strawberry.field
        def task(self, priority: Priority) -> Task:
            return Task(name="Test", priority=priority)

    schema3 = strawberry.Schema(query=QueryWithEnum)

    # Try normal enum usage
    query = """
    query {
        task(priority: HIGH) {
            name
            priority
        }
    }
    """

    try:
        compiled = compile_query(schema3, query)

        # Check for enum access in generated code
        if hasattr(compiled, "_jit_source"):
            if (
                "type_map[" in compiled._jit_source
                and ".values[" in compiled._jit_source
            ):
                print("\n‚ö†Ô∏è  Found enum value access in generated code")
                for line in compiled._jit_source.split("\n"):
                    if "type_map[" in line and ".values[" in line:
                        print(f"  {line.strip()}")

        result = compiled(None)
        print(f"\n‚úÖ Result: {result}")

    except Exception as e:
        print(f"\n‚ùå Error: {type(e).__name__}: {e}")


def test_nested_field_path_injection():
    """Attempt to inject through nested field paths."""
    print("\n" + "=" * 70)
    print("TEST 5: Nested Field Path Injection")
    print("=" * 70)

    @strawberry.type
    class Author:
        name: str

    @strawberry.type
    class Post:
        title: str

        @strawberry.field
        def author(self) -> Author:
            return Author(name="Alice")

    @strawberry.type
    class QueryNested:
        @strawberry.field
        def post(self) -> Post:
            return Post(title="Test Post")

    schema4 = strawberry.Schema(query=QueryNested)

    query = """
    query {
        post {
            title
            author {
                name
            }
        }
    }
    """

    try:
        compiled = compile_query(schema4, query)

        # Inspect the generated code for path handling
        if hasattr(compiled, "_jit_source"):
            print("\nüìù Generated Code Path Handling:")
            for i, line in enumerate(compiled._jit_source.split("\n"), 1):
                if "path" in line.lower() or "author" in line:
                    print(f"  {i:3d}: {line}")

        result = compiled(None)
        print(f"\n‚úÖ Result: {result}")

    except Exception as e:
        print(f"\n‚ùå Error: {type(e).__name__}: {e}")


def main():
    print("\n" + "=" * 70)
    print("JIT COMPILER CODE INJECTION VULNERABILITY TESTS")
    print("=" * 70)
    print("\nAttempting to exploit JIT compiler through various injection vectors...")
    print("If EXPLOIT_FLAG['pwned'] becomes True, we have a vulnerability!")

    test_variable_name_injection()
    test_field_alias_injection()
    test_type_name_injection()
    test_enum_value_injection()
    test_nested_field_path_injection()

    print("\n" + "=" * 70)
    print("FINAL RESULT")
    print("=" * 70)

    if EXPLOIT_FLAG["pwned"]:
        print("üö® VULNERABILITY CONFIRMED: Code injection succeeded!")
    else:
        print("‚úÖ No successful code injection detected")
        print("   (Note: GraphQL parser may have blocked attempts)")

    print("\nüìã Analysis:")
    print("  1. GraphQL parser provides first line of defense")
    print("  2. Variable names, aliases, and identifiers are validated by parser")
    print("  3. However, defense-in-depth recommends adding explicit validation")
    print("  4. Generated code should sanitize ALL user-controlled strings")

    print("\n" + "=" * 70)


if __name__ == "__main__":
    main()
