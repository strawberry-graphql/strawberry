---
title: Relay
---

# Relay Guide

## What is Relay?

The relay spec defines some interfaces that GraphQL servers can follow to allow
clients to interact with them in a more efficient way. The spec makes two core
assumptions about a GraphQL server:

1. It provides a mechanism for refetching an object
2. It provides a description of how to page through connections.

You can read more about the relay spec
[here](https://relay.dev/docs/guides/graphql-server-specification/).

### Relay implementation example

Suppose we have the following type:

```python
@strawberry.type
class Fruit:
    name: str
    weight: str
```

We want it to have a globally unique ID, a way to retrieve a paginated results
list of it and a way to refetch if if necessary. For that, we need to inherit it
from the `Node` interface, annotate its attribute that will be used for
`GlobalID` generation with `relay.NodeID` and implement its `resolve_nodes`
abstract method.

```python
import strawberry
from strawberry import relay


@strawberry.type
class Fruit(relay.Node):
    code: relay.NodeID[int]
    name: str
    weight: float

    @classmethod
    def resolve_nodes(
        cls,
        *,
        info: strawberry.Info,
        node_ids: Iterable[str],
        required: bool = False,
    ):
        return [
            all_fruits[int(nid)] if required else all_fruits.get(nid)
            for nid in node_ids
        ]


# In this example, assume we have a dict mapping the fruits code to the Fruit
# object itself
all_fruits: Dict[int, Fruit]
```

Explaining what we did here:

- We annotated `code` using `relay.NodeID[int]`. This makes `code` a
  [Private](../types/private.md) type, which will not be exposed to the GraphQL
  API, and also tells the `Node` interface that it should use its value to
  generate its `id: GlobalID!` for the `Fruit` type.

- We also implemented the `resolve_nodes` abstract method. This method is
  responsible for retrieving the `Fruit` instances given its `id`. Because
  `code` is our id, `node_ids` will be a list of codes as a string.

<Note>

The `GlobalID` gets generated by getting the base64 encoded version of the
string `<TypeName>:<NodeID>`. In the example above, the `Fruit` with a code of
`1` would have its `GlobalID` as `base64("Fruit:1")` = `RnJ1aXQ6MQ==`

</Note>

Now we can expose it in the schema for retrieval and
[pagination](./pagination/connections) like:

```python
@strawberry.type
class Query:
    node: relay.Node = relay.node()

    @connection(ListConnection[Fruit])
    def fruits(self) -> Iterable[Fruit]:
        # This can be a database query, a generator, an async generator, etc
        return all_fruits.values()
```

This will generate a schema like this:

```graphql
scalar GlobalID

interface Node {
  id: GlobalID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Fruit implements Node {
  id: GlobalID!
  name: String!
  weight: Float!
}

type FruitEdge {
  cursor: String!
  node: Fruit!
}

type FruitConnection {
  pageInfo: PageInfo!
  edges: [FruitEdge!]!
}

type Query {
  node(id: GlobalID!): Node!
  fruits(
    before: String = null
    after: String = null
    first: Int = null
    last: Int = null
  ): FruitConnection!
}
```

With only that we have a way to query `node` to retrieve any `Node` implemented
type in our schema (which includes our `Fruit` type), and also a way to retrieve
a list of fruits with pagination.

For example, to retrieve a single fruit given its unique ID:

```graphql
query {
  node(id: "<some id>") {
    id
    ... on Fruit {
      name
      weight
    }
  }
}
```

Or to retrieve the first 10 fruits available:

```graphql
query {
  fruits(first: 10) {
    pageInfo {
      firstCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    edges {
      # node here is the Fruit type
      node {
        id
        name
        weight
      }
    }
  }
}
```

### The node field

As demonstrated above, the `Node` field can be used to retrieve/refetch any
object in the schema that implements the `Node` interface.

It can be defined in the `Query` objects in 4 ways:

- `node: Node`: This will define a field that accepts a `GlobalID!` and returns
  a `Node` instance. This is the most basic way to define it.
- `node: Optional[Node]`: The same as `Node`, but if the given object doesn't
  exist, it will return `null`.
- `node: List[Node]`: This will define a field that accepts `[GlobalID!]!` and
  returns a list of `Node` instances. They can even be from different types.
- `node: List[Optional[Node]]`: The same as `List[Node]`, but the returned list
  can contain `null` values if the given objects don't exist.

### The connection field

The connection field, although defined in the relay specifications, is actually
a well-known pattern in GraphQL for getting paginated results.

Because of that, it is implemented in Strawberry as a generic pagination
solution, which you can read more about in the
[pagination](./pagination/connections) page.

### The GlobalID scalar

The `GlobalID` scalar is a special object that contains all the info necessary
to identify and retrieve a given object that implements the `Node` interface.

It can for example be useful in a mutation, to receive and object and retrieve
it in its resolver. For example:

```python
@strawberry.type
class Mutation:
    @strawberry.mutation
    async def update_fruit_weight(
        self,
        info: strawberry.Info,
        id: relay.GlobalID,
        weight: float,
    ) -> Fruit:
        # resolve_node will return an awaitable that returns the Fruit object
        fruit = await id.resolve_node(info, ensure_type=Fruit)
        fruit.weight = weight
        return fruit

    @strawberry.mutation
    def update_fruit_weight_sync(
        self,
        info: strawberry.Info,
        id: relay.GlobalID,
        weight: float,
    ) -> Fruit:
        # resolve_node will return the Fruit object
        fruit = id.resolve_node_sync(info, ensure_type=Fruit)
        fruit.weight = weight
        return fruit
```

In the example above, you can also access the type name directly with
`id.type_name`, the raw node ID with `id.id`, or even resolve the type itself
with `id.resolve_type(info)`.
